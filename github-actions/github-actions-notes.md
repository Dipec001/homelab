
## Github Actions
- **What is Github actions:** This is a CI/CD platform that allows us to automate our build, test and deployment pipelines.
- **Workflows:** These are configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked
 in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a
 defined schedule.The events could be a push, pr, issue creation etc
 Workflows are defined in the *.github/workflows* directory in a repository and a repo can contain multiple workflows

- **Events:** An event is a specific activity in a repository that triggers a workflow run. For example, an activity can originate
 from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository.There are so many events
that could trigger a workflow, you can see them <a href="https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows">here</a>
- **Jobs:** A job is a set of steps in a workflow that is executed on the same runner. Each step is either a shell script that
 will be executed, or an action that will be run. Steps are executed in order and are dependent on each other.
A workflow can have multiple jobs running in parallel or sequentially. Jobs that are supposed to run sequentially will use the *needs*
to specify dependencies. When jobs run, they do so in separate virtual machines (VMs) or containers and runners have to be
specified in each job, they also don’t have shared memory or a shared  environment by default. But GitHub Actions provides ways to
 pass data (like files or artifacts) between dependent jobs.
● Artifacts are files generated by one job that can be uploaded, stored, and later downloaded by other jobs.
● Environment Variables or Outputs – You can also pass small pieces of data (like environment variables) between jobs.
- **Actions:** An action is a custom application for the GitHub Actions platform that performs a complex but frequently repeated
 task. Use an action to help reduce the amount of repetitive code that you write in your workflow files

- **job_id:** This is the string given to the job, it is at the location of `jobs.<job_id>`. It is a unique identifier given to
the particular job in the workflow. The string must start with a letter or an _
- **job name:** THis is a name given to the job, it is at `jobs.<job_id>.name`. 
- **needs:** THis is used to specify jobs that must complete before other jobs. it is specified at `jobs.<job_id>.needs`

**Example:** Requiring successful dependent jobs
jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]
In this example, job1 must complete successfully before job2 begins, and job3 waits for both job1 and job2 to complete.

The jobs in this example run sequentially:

job1
job2
job3

- **Configuration Variables:** A configuration variable in GitHub Actions is a key-value pair used to store data that you can reference in your
 workflows. These variables help manage reusable information and secrets across jobs and steps in a GitHub Actions workflow.
Example:
```yaml
name: Greeting on variable day

on:
  workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: "Say Hello Mona it's Monday"
        run: echo "$Greeting $First_Name. Today is $DAY_OF_WEEK!"
        env:
          First_Name: Mona
```
The values for these variables *$DAY_OF_WEEK*, *$Greeting*, and *$First_Name* are set, and scoped, at the workflow, job, and step
 level respectively.
These are above are environment variables and are defined in the workflow
There are a different type of configuration variables in github actions called *Secrets*. These are *Sensitive Variables * that
we would generally not want exposed.It is used for securely storing sensitive information like API keys, tokens, or passwords.
 These are encrypted and hidden in workflow logs.
Example:
```bash
jobs:
  build:
    runs-on: ubuntu-latest
    env:
      API_TOKEN: ${{ secrets.API_TOKEN }}
    steps:
      - name: Access API token
        run: echo "The API token is set, but its value won't be visible in logs!"
```
Secrets are added manually in the GitHub repository under Settings > Secrets and Variables > Actions.

Reference secrets using ${{ secrets.SECRET_NAME }}.

## Defining Repo-Wide Configuration Variables

If the variable will be reused across multiple workflows in the same repository, you can define it as a configuration variable (vars) at the repository level.

Steps to Add Repo-Wide vars:

Go to Repository Settings → Secrets and variables → Actions → Variables → New Variable.

Define your variable, e.g., DEPLOY_ENV = production.

Example 
```yaml
name: Repo-Wide Vars Example
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      DEPLOY_ENV: ${{ vars.DEPLOY_ENV }}  # Accessing the repo-level configuration variable
    steps:
      - run: echo "Deploying to $DEPLOY_ENV"
```

- **Matrix Strategy:** A matrix strategy lets you use variables in a single job definition to automatically create multiple job
 runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in
 multiple versions of a language or on multiple operating systems.
To use matrix strategy, you define your configuration in the `jobs.<job.id>.strategy.matrix`. Within your matrix, define one or 
more variables, followed by an array of values. 
Example:
```yaml
jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]
```
In the example above, the workflow will run six jobs, one for each combination of the os and version variables.

- **Caching in Github actions:** caching helps reduce workflow execution time by saving dependencies or frequently used files from
 one workflow run and reusing them in subsequent runs. Instead of re-installing or re-downloading the same files repeatedly, a
 cache is used to improve performance and efficiency. 
To implement caching, GitHub provides the official action:
```yaml
- uses: actions/cache@v3
  with:
    path: <path-to-cache>         # Directory to cache (e.g., dependencies folder)
    key: <cache-key>              # Unique key identifying the cache
    restore-keys: <fallback-key>  # Fallback key to use if an exact match is not found
```
Parameters Explained:

● path:
This is the file path where the cache will be saved and restored. It can be a specific folder like node_modules or .venv.

● key:
The cache key uniquely identifies the cache. You usually create it dynamically to reflect changes (e.g., based on dependencies).
Example: key: python-pip-cache-${{ hashFiles('**/requirements.txt') }} generates a cache key based on your requirements.txt.

● restore-keys: (Optional)
This allows GitHub Actions to use partial cache matches if an exact match for the key isn’t found.




